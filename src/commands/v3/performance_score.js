const { SlashCommandBuilder } = require('discord.js');
const { createCustomEmbed, createErrorEmbed } = require('../../utils/embeds');
const { User, Activity, Shift } = require('../../database/mongo');

module.exports = {
  data: new SlashCommandBuilder()
    .setName('performance_score')
    .setDescription('View an algorithmic performance ranking analysis')
    .addUserOption(option =>
      option.setName('user')
        .setDescription('User to check performance for')
        .setRequired(false)),

  async execute(interaction) {
    try {
      await interaction.deferReply();
      const targetUser = interaction.options.getUser('user') || interaction.user;
      const guildId = interaction.guildId;

      const user = await User.findOne({ userId: targetUser.id, guildId }).lean();
      if (!user || !user.staff) {
        return interaction.editReply({ embeds: [createErrorEmbed(`No staff records found for <@${targetUser.id}> inside this server.`)] });
      }

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const activities = await Activity.find({
        guildId,
        userId: targetUser.id,
        createdAt: { $gte: thirtyDaysAgo }
      }).lean();

      const shifts = await Shift.find({
        guildId,
        userId: targetUser.id,
        startTime: { $gte: thirtyDaysAgo }
      }).lean();

      const commands = activities.filter(a => a.type === 'command').length;
      const warnings = activities.filter(a => a.type === 'warning').length;
      const completedShifts = shifts.filter(s => s.endTime).length;
      const totalShifts = shifts.length;

      const shiftCompletionRate = totalShifts > 0 ? (completedShifts / totalShifts) * 100 : 0;
      const consistency = user.staff?.consistency || 100;
      const points = user.staff?.points || 0;
      const reputation = user.staff?.reputation || 0;

      const performanceScore = calculatePerformanceScore(commands, warnings, shiftCompletionRate, consistency, reputation);
      const grade = getGrade(performanceScore);

      const filledScore = Math.min(10, Math.floor(performanceScore / 10));
      const progressBar = `\`${'█'.repeat(filledScore)}${'░'.repeat(10 - filledScore)}\``;

      const embed = await createCustomEmbed(interaction, {
        title: `📊 Operational Performance: ${targetUser.username}`,
        description: `Analyzing overlapping timeline activity generated by <@${targetUser.id}> throughout the last 30 days.`,
        thumbnail: targetUser.displayAvatarURL(),
        fields: [
          { name: '💯 Algorithmic Output', value: `${progressBar} **${grade}**`, inline: false },
          { name: '✅ Command Usage', value: `\`${commands}\``, inline: true },
          { name: '⚠️ Disruption Count', value: `\`${warnings}\` Strikes`, inline: true },
          { name: '🔄 Retention Target', value: `\`${shiftCompletionRate.toFixed(1)}%\``, inline: true },
          { name: '📈 Global Consistency', value: `\`${consistency}%\``, inline: true },
          { name: '⭐ Validated Points', value: `\`${points}\``, inline: true },
          { name: '💫 Reputation Nodes', value: `\`${reputation}\``, inline: true }
        ],
        footer: 'Analytic output derived against true Guild mapping constraints.'
      });

      await interaction.editReply({ embeds: [embed] });

    } catch (error) {
      console.error('Performance Score Error:', error);
      const errEmbed = createErrorEmbed('A database error occurred plotting performance trajectory charts.');
      if (interaction.deferred || interaction.replied) {
        await interaction.editReply({ embeds: [errEmbed] });
      } else {
        await interaction.reply({ embeds: [errEmbed], ephemeral: true });
      }
    }
  }
};

function calculatePerformanceScore(commands, warnings, shiftCompletion, consistency, reputation) {
  const commandScore = Math.min(30, commands * 2);
  const warningScore = Math.max(0, 20 - warnings * 5);
  const shiftScore = (shiftCompletion / 100) * 25;
  const consistencyScore = (consistency / 100) * 15;
  const reputationScore = Math.min(10, reputation / 10);

  return Math.round(commandScore + warningScore + shiftScore + consistencyScore + reputationScore);
}

function getGrade(score) {
  if (score >= 90) return 'A+';
  if (score >= 80) return 'A';
  if (score >= 70) return 'B';
  if (score >= 60) return 'C';
  if (score >= 50) return 'D';
  return 'F';
}
